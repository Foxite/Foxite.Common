using System;
using System.Collections.Generic;

namespace Foxite.Common.Unity.Pathfinding {
	public abstract class PathfindingCell : IEquatable<PathfindingCell> {
		/// <summary>
		/// Cells that can be reached directly when standing on this cell.
		/// It is highly recommended that you use lazy evaluation for this, as doing so eliminates all wasted effort from preparing a list of cells if not all of them will be visited.
		///
		/// Ensure that you only return instances of your own class from this property. Otherwise, pathfinders will throw an InvalidOperationException when they encounter the wrong type of cell.
		/// </summary>
		public abstract IEnumerable<PathfindingCell> Neighbors { get; }
		
		public abstract int Heuristic(PathfindingCell pfc);

		public abstract bool Equals(PathfindingCell other);
		public abstract override int GetHashCode();

		public override bool Equals(object obj) => obj is PathfindingCell pfc && Equals(pfc);
		
		public static bool operator ==(PathfindingCell left, PathfindingCell right) => left?.Equals(right) ?? right is null;
		public static bool operator !=(PathfindingCell left, PathfindingCell right) => !(left == right);
	}
	
	public abstract class CostlyPathfindingCell : PathfindingCell {
		/// <summary>
		/// The Cost of this CostlyPathfindingCell when enumerated by another cell's Neighbors property, is the cost of moving from this cell to that cell.
		/// </summary>
		public abstract int Cost { get; }

		public int CompareTo(CostlyPathfindingCell other) => Cost.CompareTo(other.Cost);
		public abstract bool Equals(CostlyPathfindingCell other);
		public abstract override int GetHashCode();

		public override bool Equals(object obj) => obj is CostlyPathfindingCell pfc && Equals(pfc);

		public static bool operator ==(CostlyPathfindingCell left, CostlyPathfindingCell right) => left?.Equals(right) ?? right is null;
		public static bool operator !=(CostlyPathfindingCell left, CostlyPathfindingCell right) => !(left == right);

		// Operators generated by VS
		public static bool operator < (CostlyPathfindingCell left, CostlyPathfindingCell right) => left is null ? !(right is null) : left.CompareTo(right) < 0;
		public static bool operator <=(CostlyPathfindingCell left, CostlyPathfindingCell right) => left is null || left.CompareTo(right) <= 0;
		public static bool operator > (CostlyPathfindingCell left, CostlyPathfindingCell right) => !(left is null) && left.CompareTo(right) > 0;
		public static bool operator >=(CostlyPathfindingCell left, CostlyPathfindingCell right) => left is null ? right is null : left.CompareTo(right) >= 0;
	}
	
	// public class HexPathfindingCell : PathfindingCell {
	// 	public Hex TheHex { get; }
	//
	// 	public override int Cost => 1;
	//
	// 	// Thanks to LINQ this is lazily evaluated. If we happen to find a path after only a few steps, then we won't have wasted a bunch of time preparing a list of cells to visit.
	// 	public override IEnumerable<PathfindingCell> Neighbors =>
	// 		from pos in HexUtil.CubeSixDirections(TheHex.CubePosition)
	// 		let hex = TheHex.Grid.TryGetHex(pos, out Hex ret) ? ret : null
	// 		where hex != null
	// 		select new HexPathfindingCell(hex);
	//
	// 	public HexPathfindingCell(Hex hex) {
	// 		TheHex = hex;
	// 	}
	//
	// 	public override int Heuristic(PathfindingCell pfc) => pfc is HexPathfindingCell hpc
	// 		? HexUtil.CubeDistance(hpc.TheHex.CubePosition, hpc.TheHex.CubePosition)
	// 		: throw new ArgumentException("Received a PFC that does not derive from HexPathfindingCell");
	//
	// 	public override bool Equals(PathfindingCell other) => other is HexPathfindingCell hpc && TheHex.CubePosition.Equals(hpc.TheHex.CubePosition);
	// 	public override int GetHashCode() => TheHex.CubePosition.GetHashCode();
	// }
}
